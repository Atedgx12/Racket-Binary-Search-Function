#lang racket

(define g6-tree-insert
  (lambda (num tree)
    (cond    
      ((null? tree)
       (list num))   
      ((and (list? tree) (= (length tree) 1))
       (let ((root (car tree)))
         (if (< num root)  
             (list root (list (list num) '()))   
             (list root (list (list num))))))
      ((and (list? tree) (= (length tree) 2))
       (let* ((root (car tree))
              (children (cadr tree))
              (left (if (pair? children) (car children) '()))
              (right (if (pair? children) (cadr children) '())))
         (if (< num root)      
             (list root (list (g6-tree-insert num left) right))      
             (list root (list left (g6-tree-insert num right)))))))))
(displayln "Binary Tree Insertion")
(newline)
(display (g6-tree-insert 8 '()))  
(newline)
(display (g6-tree-insert 12 '(8)))  
(newline)
(display (g6-tree-insert 3 '(8)))  
(newline)
(display (g6-tree-insert 12 '(8 ((3) ()))))  
(newline)
(display (g6-tree-insert 4 '(8 ((3) (12)))))  
(newline)
(newline)
(define g7-tree-insert
  (lambda (num tree)
    (cond 
      ((null? tree)
       (list num))    
      ((and (list? tree) (= (length tree) 1))
       (let ((root (car tree)))
         (if (< num root)          
             (list root (list (list num) '()))           
             (list root (list (list num))))))     
      ((and (list? tree) (= (length tree) 2))
       (let* ((root (car tree))
              (children (ensure-two-elements (cadr tree))) 
              (left (car children))
              (right (cadr children)))
         (if (< num root)
             (list root (list (g7-tree-insert num left) right))      
             (list root (list left (g7-tree-insert num right))))))
      (else (error "Tree is malformed")))))
(define (ensure-two-elements lst)
  (cond
    [(null? lst) (list '() '())] 
    [(= (length lst) 1) (list (car lst) '())]  
    [else lst])) 
(define (print-tree tree)
  (cond
    [(null? tree) (display "()")] 
    [else
     (display "(")
     (for-each print-tree-element tree)
     (display ")")]))
(define (print-tree-element elem)
  (if (list? elem)
      (print-tree elem) 
      (display elem)))  
(define (main)
  (display "Enter numbers separated by spaces: ")
  (newline)
  (let* ([input (read-line)]
         [input-list (string-split input)]
         [numbers (filter-map string->valid-number input-list)]) 
    (if (empty? numbers)
        (begin
          (display "Error: Please enter valid numbers only.")
          (newline))
        (let ([tree (foldl g7-tree-insert '() numbers)])
          (newline)
          (print-tree tree)  
          (newline))))) 
(define (string->valid-number str)
  (with-handlers ([exn:fail? (lambda (_) #f)])  
    (string->number str)))
(define (j23-tree-insert num tree)
  (cond
    ((null? tree)
     (list num (list '() '())))
    ((and (list? tree) (= (length tree) 1))
     (let ((root (car tree)))
       (if (< num root)
           (list root (list (list num) '()))
           (list root (list (list num))))))          
    ((and (list? tree) (= (length tree) 2))
     (let* ((root (car tree))
            (children (cadr tree))
            (left (car children))
            (right (cadr children)))
       (cond
         ((< num root)
          (list root (list (j23-tree-insert num left) right)))
         ((> num root)
          (list root (list left (j23-tree-insert num right))))
         (else
          (list root (list (j23-tree-insert num left) right))))))   
    (else (error "Tree is malformed"))))
(define (j23-list-to-tree lst)
  (foldl j23-tree-insert '() lst))
(define (j23-get-left tree)
  (if (and (list? tree) (>= (length tree) 2))
      (let ([children (cadr tree)])
        (if (pair? children)
            (car children)
            '()))
      '()))
(define (j23-get-right tree)
  (if (and (list? tree) (>= (length tree) 2))
      (let ([children (cadr tree)])
        (if (and (pair? children) (>= (length children) 2))
            (cadr children)
            '()))
      '()))
(define (j23-custom-display tree)
  (cond 
    [(null? tree) '()]
    [(and (pair? tree) (null? (j23-get-left tree)) (null? (j23-get-right tree)))
     (list (car tree))]
    [else
      (let ([left (j23-custom-display (j23-get-left tree))]
            [right (j23-custom-display (j23-get-right tree))])
        (cond
          [(and (not (null? left)) (not (null? right)))
           (list (car tree) (list left right))]
          [(not (null? left))
           (list (car tree) (list left '()))]
          [(not (null? right))
           (list (car tree) (list right))]))]))

(define (j23-display-tree tree) 
  (display "(")
  (write tree)
  (display ")")
  (newline))

(define (j23-inorder-traversal tree)
  (cond
    [(null? tree) '()]
    [else
     (append
      (j23-inorder-traversal (j23-get-left tree))
      (list (car tree))
      (j23-inorder-traversal (j23-get-right tree)))]))
(displayln "Part 1: Simple Tree Insert")
(displayln "Testing with list (8 3 12 4):")
(newline)
(define g7-test-list '(8 3 12 4))
(define g7-tree (foldl g7-tree-insert '() g7-test-list))
(display "Simple List-to-Tree structure: ")
(print-tree g7-tree)
(newline)
(newline)
(newline)
(displayln "Part 2: List-to-Tree Display")
(displayln "Testing same list with list-to-tree:")
(newline)
(displayln "List for Tree: (22 25 7 16 8 34 67 7 32 17 8 4 5 3 19)")
(newline)
(newline)
(displayln "Predicted output '(22 ((7 ((7 ((4 ((3) (5))) ())) (16 ((8 ((8) ())) (17 ((19)))))))\n (25 ((34 ((32) (67)))))))")
(newline)
(define test-list '(22 25 7 16 8 34 67 7 32 17 8 4 5 3 19))
(define test-tree (j23-list-to-tree test-list))(newline)
(display "Actual Output: ")
(newline)
(j23-custom-display test-tree)
(newline)
(display "Inorder traversal: ")
(display (j23-inorder-traversal test-tree))
(newline)
(newline)
(display "Enter numbers separated by spaces for YOUR tree: ")
(let* ([input (read-line)]
       [input-list (string-split input)]
       [numbers (filter-map string->valid-number input-list)])
  (if (empty? numbers)
      (begin
        (display "Error: Please enter valid numbers only.")
        (newline))
      (let ([user-tree (j23-list-to-tree numbers)])
        (display "Your tree structure: ")
        (j23-custom-display user-tree)
        (newline))))
        
